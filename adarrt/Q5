
Q5

Here is the path previously we have got. 

Path waypoints:
[[-1.5         3.22        1.23       -2.19        1.8         1.2       ]
 [-1.66120364  3.36553493  1.16407034 -2.24708011  1.84643123  1.27464751]
 [-1.72406054  3.53474787  1.06664176 -2.15889114  1.95589638  1.30041085]
 [-1.80789302  3.50115124  1.2610341  -2.1563178   2.08380806  1.2867368 ]
 [-1.8930764   3.54297972  1.31299887 -2.20848974  2.03625024  1.50076992]
 [-1.94021355  3.71321265  1.39765924 -2.10530159  2.14669705  1.53661918]
 [-2.08478427  3.84629937  1.31659023 -2.00570618  2.14352841  1.62255962]
 [-2.17106476  3.94435407  1.21857635 -2.12629788  2.09371614  1.75971141]
 [-2.17933586  4.06015931  1.39610032 -2.22267105  2.15656326  1.82504463]
 [-2.0887359   4.18748195  1.51160204 -2.19767072  2.25055904  1.70143346]
 [-1.72        4.44        2.02       -2.04        2.66        1.39      ]]

Then, the following is the path that uses _get_random_sample_near_goal method with 0.2 goal precision.

Path waypoints:
[[-1.5         3.22        1.23       -2.19        1.8         1.2       ]
 [-1.53724943  3.39540482  1.33779584 -2.1643001   1.93048836  1.23221786]
 [-1.70824448  3.40649689  1.3181642  -2.12437642  1.98960081  1.39854308]
 [-1.70847165  3.5927638   1.4432079  -2.10811981  2.0984733   1.40569607]
 [-1.83133384  3.73165706  1.52330233 -2.03699813  2.22450997  1.43317135]
 [-1.72        4.44        2.02       -2.04        2.66        1.39      ]]



As we can observe, even though the final accuracy is more accurate due to smaller goal precision, using the sample near the goal, we can actually find the path within the smaller number of iteration leading to smaller amount of computation. 

 





  
